/************ ইন্টারভিউ প্রশ্ন ***************
 * 
 * ১. জাভাস্ক্রিপ্ট কী কী ডাটা টাইপের ভেরিয়েবল আছে?
 * 
 * =>জাভাস্ক্রিপ্টে মোট ৮ ধরনের ডাটা টাইপ রয়েছে, যা মূলত দুই ভাগে বিভক্ত: Primitive এবং Non-Primitive (Reference)।

১. Primitive Data Types:
 String: টেক্সট বা অক্ষরের ক্রম যেমন "Hello", "Rahat".
 Number: সকল ধরণের সংখ্যা যেমন, 123, 3.14.
 Boolean: লজিক্যাল মান, যা হয় true অথবা false হতে পারে।
 Undefined: ভেরিয়েবল ডিক্লেয়ার করা হয়েছে কিন্তু কোনো মান নির্ধারণ করা হয়নি।
 Null: ইচ্ছাকৃতভাবে কোনো ভেরিয়েবলকে খালি করা হয়।
 Symbol: ইউনিক এবং অপরিবর্তনশীল মানের জন্য ব্যবহৃত হয়।
 BigInt: বড় ইন্টিজার মানের জন্য, যেমন 9007199254740991n।

২. Non-Primitive (Reference) Data Types:
 Object: এটি অনেক ধরণের মান ধারণ করতে পারে, যেমন { name: "Rahat", age: 25 }।
 এর মধ্যে Array এবং Function-ও অন্তর্ভুক্ত থাকে:
 Array: একাধিক মানের তালিকা যেমন [1, 2, 3]।
 Function: কোড ব্লক যা বিভিন্ন কাজ সম্পাদন করতে ব্যবহৃত হয়।
 এগুলো জাভাস্ক্রিপ্টের প্রধান ডাটা টাইপ, যা কোড লেখার সময় ভিন্ন ভিন্ন প্রয়োজনে ব্যবহার করা হয়।

**************************************
 * ২. জাভাস্ক্রিপ্ট ফাংশন, বা array কি টাইপের জিনিস ? 
 * 
 * =>জাভাস্ক্রিপ্টে ফাংশন (Function) এবং অ্যারে (Array) — দুটিই Non-Primitive বা Reference টাইপের ডাটা, এবং এদেরকে Object হিসাবে বিবেচনা করা হয়।
 * 
 * Example:
 * ১. ফাংশন (Function):
জাভাস্ক্রিপ্টে, ফাংশন হলো এক ধরণের Object। যদিও এটি বিশেষভাবে ব্যবহার করা হয় কাজ বা অপারেশন সম্পাদনের জন্য, এর প্রকৃতি Object-এর মতোই। আপনি যদি typeof অপারেটর দিয়ে ফাংশনের টাইপ চেক করেন, এটি function রিটার্ন করবে, কিন্তু ফাংশন আসলে Object টাইপের ডাটা।
 * 
 * ২. অ্যারে (Array):
অ্যারে জাভাস্ক্রিপ্টে একটি Object। এটি হল Object-এর একটি বিশেষ ফর্ম, যেখানে ইনডেক্সড ভ্যালুর লিস্ট থাকে। অ্যারে জাভাস্ক্রিপ্টের অন্যান্য Object-এর মতো আচরণ করে, তবে এটি বিশেষভাবে অনেক মান ধরে রাখার জন্য ব্যবহৃত হয়।
 * 
 * **************************************
 * ৩. জাভাস্ক্রিপ্ট এ array যদি অবজেক্ট হয় তাহলে কিভাবে চেক করবে কোন একটা ভেরিয়েবল একটা array নাকি array না?
 * =>জাভাস্ক্রিপ্টে কোনো ভেরিয়েবল Array কিনা তা নির্ধারণ করার জন্য একটি নির্দিষ্ট পদ্ধতি রয়েছে। যদিও অ্যারে একটি Object, typeof অপারেটর ব্যবহার করলে এটি সবসময় object রিটার্ন করবে। তাই, অ্যারে চেক করার জন্য একটি বিশেষ মেথড রয়েছে:
 * 
 * Exmple:
 * Array.isArray() মেথড:
এই মেথডটি ব্যবহার করে আপনি নির্ভুলভাবে পরীক্ষা করতে পারেন যে কোনো ভেরিয়েবলটি একটি অ্যারে কিনা।
 *
 * **************************************
 * ৪. এর মধ্যে undefined আর null এর মধ্যে ডিফারেন্স কি। 
 * =>জাভাস্ক্রিপ্টে undefined এবং null এর মধ্যে কয়েকটি গুরুত্বপূর্ণ পার্থক্য রয়েছে, যদিও দুটিই "খালি" বা "অপ্রাপ্য" মান নির্দেশ করে।
 * 
 *  Exmple:
 * ১. undefined:
অর্থ: যখন কোনো ভেরিয়েবল ডিক্লেয়ার করা হয়েছে, কিন্তু সেটিতে কোনো মান নির্ধারণ করা হয়নি, তখন তার মান হয় undefined।
ব্যবহার: সাধারণত জাভাস্ক্রিপ্ট নিজে থেকে কোনো ভেরিয়েবলকে undefined দেয় যদি তাকে কোনো মান না দেয়া হয়।
টাইপ: এটি একটি Primitive টাইপ এবং এর typeof মান undefined।

২. null:
অর্থ: null হলো একটি ইচ্ছাকৃতভাবে "খালি" বা "অকার্যকর মান" নির্দেশ করার জন্য ব্যবহৃত হয়।
ব্যবহার: প্রোগ্রামাররা সাধারণত কোনো ভেরিয়েবলকে ইচ্ছাকৃতভাবে "খালি" করতে চাইলে তাকে null দেয়।
টাইপ: মজার ব্যাপার হলো, null এর typeof রিটার্ন করে object, যা জাভাস্ক্রিপ্টের একটি ঐতিহাসিক ভুল, তবে এটি এখনো একইভাবে আছে।

মূল পার্থক্য:
বৈশিষ্ট্য ||	undefined  ||	null
অর্থ  ||	ভেরিয়েবল ডিক্লেয়ার করা হয়েছে কিন্তু মান নেই।  ||	ইচ্ছাকৃতভাবে ভেরিয়েবলকে "খালি" করা হয়েছে।
কে সেট করে? ||	জাভাস্ক্রিপ্ট স্বয়ংক্রিয়ভাবে সেট করে। ||   প্রোগ্রামার ইচ্ছাকৃতভাবে সেট করে।
টাইপ  ||	undefined  ||	object
ব্যবহার	 || সাধারণত মান নির্ধারণের আগে ভেরিয়েবল থাকে।  ||	কোনো ভেরিয়েবলকে ইচ্ছাকৃতভাবে খালি করা হয়।

এই উদাহরণে undefined এবং null এর মধ্যে পার্থক্য ভালোভাবে বোঝা যায়। == চেক করলে তারা সমান দেখায়, কিন্তু === দিয়ে টাইপসহ চেক করলে তাদের মধ্যে পার্থক্য ধরা পড়ে।
 *
 * ************************
 * ৫. double equal (==) আর triple equal (===) এই দুইটার মধ্যে ডিফারেন্স কি। 
 * => জাভাস্ক্রিপ্টে double equal (==) এবং triple equal (===) এর মধ্যে প্রধান পার্থক্য হলো type coercion। চলুন দুইটার পার্থক্য বিশ্লেষণ করি:
 * 
 * Exmple:
 * ১. Double Equal (==):
এটি শুধুমাত্র মান (value) তুলনা করে।
তুলনা করার আগে type coercion ঘটায়, অর্থাৎ যদি দুই ভেরিয়েবলের টাইপ ভিন্ন হয়, তাহলে তাদেরকে একই টাইপে রূপান্তরিত করে তারপর মান পরীক্ষা করা হয়।

২. Triple Equal (===):
এটি মান এবং টাইপ উভয়ই পরীক্ষা করে।
কোনো type coercion ঘটায় না, অর্থাৎ দুই ভেরিয়েবলের টাইপ যদি ভিন্ন হয়, তাহলে তারা সমান হবে না।
 * 
 **************************
 * ৬. implicit conversion কি জিনিস? এটা কখন হয়?
 * => 
Implicit conversion বা type coercion হলো জাভাস্ক্রিপ্টের একটি প্রক্রিয়া, যেখানে এটি স্বয়ংক্রিয়ভাবে এক ডেটা টাইপকে অন্য টাইপে রূপান্তর করে যখন ভিন্ন টাইপের মানের সাথে অপারেশন বা তুলনা করা হয়।

 কখন ঘটে:
তুলনা অপারেটর (==) ব্যবহার করার সময়।
লজিক্যাল অপারেশন যেমন if, &&, || এর সময়।
অ্যারিথমেটিক অপারেশন যেমন +, -, *, / এর সময় ভিন্ন টাইপের ডেটার মধ্যে।
 * 
 ***************************
 *৭. এছাড়াও জাভাস্ক্রিপ্ট এ কয়েক ধরনের স্কোপ আছে। এই স্কোপ গুলার মধ্যে ডিফারেন্স কি। কখন কোনটা হয়। 
 * 
 *=> জাভাস্ক্রিপ্টে মূলত তিন ধরনের স্কোপ (scope) আছে, যা ভেরিয়েবলের অ্যাক্সেস বা প্রাপ্যতা নির্ধারণ করে:
 *Exmple:
১. Global Scope:
কোনো ভেরিয়েবল বা ফাংশন গ্লোবালি ডিক্লেয়ার করা হলে সেটি পুরো স্ক্রিপ্ট জুড়ে যেকোনো জায়গা থেকে অ্যাক্সেস করা যায়।
var, let, বা const দিয়ে বাইরে ডিক্লেয়ার করা হলে এটি গ্লোবাল হয়।

২. Function Scope:
ফাংশনের ভেতরে ডিক্লেয়ার করা ভেরিয়েবল কেবলমাত্র সেই ফাংশনের ভেতরেই অ্যাক্সেসযোগ্য থাকে।
var দিয়ে ফাংশনের ভেতরে ডিক্লেয়ার করলে এটি ফাংশন স্কোপে থাকবে।

৩. Block Scope:
ব্লক (যেমন if, for, while) এর মধ্যে let বা const দিয়ে ডিক্লেয়ার করা ভেরিয়েবল শুধুমাত্র সেই ব্লকের মধ্যে অ্যাক্সেসযোগ্য থাকে।
ব্লক স্কোপ ES6 থেকে এসেছে।

মূল পার্থক্য:
Global Scope: পুরো স্ক্রিপ্ট জুড়ে অ্যাক্সেসযোগ্য।
Function Scope: শুধু ফাংশনের ভেতরে অ্যাক্সেসযোগ্য (ফাংশন ভেরিয়েবল)।
Block Scope: ব্লকের মধ্যে অ্যাক্সেসযোগ্য (ব্লক ভেরিয়েবল)।

***************************
 * ৮. ব্লক স্কোপ কি জিনিস? let, const কি টাইপের স্কোপ তৈরি করে?
 * =>ব্লক স্কোপ হলো একটি স্কোপ যা কোনো {} ব্রেসেস (যেমন if, for, বা ফাংশনের ভিতরের ব্লক) এর মধ্যে থাকা ভেরিয়েবলগুলোকে সীমাবদ্ধ করে। এই স্কোপের মধ্যে থাকা ভেরিয়েবলগুলো ব্লকের বাইরে অ্যাক্সেস করা যায় না।

*Exmple:
let এবং const:
let এবং const উভয়ই ব্লক স্কোপ তৈরি করে।
এদের মাধ্যমে ডিক্লেয়ার করা ভেরিয়েবল শুধু নির্দিষ্ট ব্লকের ভেতরেই অ্যাক্সেসযোগ্য, ব্লকের বাইরে নয়।

 *সংক্ষেপে: let এবং const ব্লক স্কোপ তৈরি করে, যেখানে ভেরিয়েবল শুধু ব্লকের মধ্যে সীমাবদ্ধ থাকে।

 ****************************
 *৯. (এডভান্সড) Closure কি জিনিস? এইটা কিভাবে কাজ করে?
 *=>Closure হলো জাভাস্ক্রিপ্টের একটি শক্তিশালী ফিচার, যেখানে একটি ফাংশন তার আউটার ফাংশনের স্কোপ (parent function বা lexical environment) থেকে ভেরিয়েবল অ্যাক্সেস করতে পারে, এমনকি আউটার ফাংশন এক্সিকিউশন শেষ হয়ে গেলেও। অর্থাৎ, একটি ইননার ফাংশন আউটার ফাংশনের ভেরিয়েবলকে মেমরিতে ধরে রাখে এবং ব্যবহার করতে পারে।

 *Exmple:
Closure কিভাবে কাজ করে:
যখন কোনো ফাংশন তার ভিতরে আরেকটি ফাংশন ডিক্লেয়ার করে এবং সেই ইননার ফাংশন আউটার ফাংশনের ভেরিয়েবল ব্যবহার করে, তখন Closure তৈরি হয়।
Closure সেই ভেরিয়েবলগুলোকে "বন্ধ" করে রাখে এবং ভবিষ্যতে যেকোনো সময় ব্যবহার করতে দেয়, এমনকি আউটার ফাংশন শেষ হলেও।

সংক্ষেপে: Closure একটি ফাংশনকে তার আউটার স্কোপের ভেরিয়েবল ধরে রাখার সুযোগ দেয়, এমনকি আউটার ফাংশন শেষ হওয়ার পরও।
 * 
 ****************************
 * ১০. Callback function কি জিনিস?
 * =>Callback function হলো একটি ফাংশন যা অন্য একটি ফাংশনের আর্গুমেন্ট হিসাবে পাস করা হয় এবং পরবর্তী সময়ে ওই ফাংশনের মধ্যে কখনও এক্সিকিউট হয়। সাধারণত, এই ফাংশনগুলি আসynchronous অপারেশন সম্পন্ন হওয়ার পরে বা কিছু নির্দিষ্ট কাজ করার পর ডাকা হয়।

*Exmple:
কিভাবে কাজ করে:
একটি ফাংশন তৈরি করুন যা অন্য একটি ফাংশনকে আর্গুমেন্ট হিসেবে গ্রহণ করে।
প্রধান ফাংশনটি যখন কাজ শেষ করবে, তখন কলব্যাক ফাংশনটি কল করবে।

সংক্ষেপে:
Callback function হলো একটি ফাংশন যা অন্য একটি ফাংশনের মধ্যে পাস করা হয় এবং পরে এক্সিকিউট করা হয়। এটি সাধারণত asynchronous অপারেশন এবং ইভেন্ট হ্যান্ডলিংয়ের জন্য ব্যবহৃত হয়।
 * 
 *******************************************************************************************************************************
 * ১১. Hoisting কি জিনিস? (গুগলে সার্চ দিয়ে আরো ভালো করে শিখো )
 * *****************************************************************************************************************************
 * 
 * ১২. (এডভান্সড) কি ধরণের ভেরিয়েবল reference দিয়ে ফাংশনে পাঠানো হয় আর কোন ধরণের ভেরিয়েবল value হিসেবে পাঠানো হয়। 
 *=>JavaScript-এ ভেরিয়েবল পাঠানোর সময় তাদের রেফারেন্স (reference) অথবা ভ্যালু (value) হিসেবে পাঠানো হয়। এটি মূলত ডেটার টাইপের ওপর নির্ভর করে। নিচে এ সম্পর্কে বিশদ আলোচনা করা হলো:

*Exmple: 
১. ভ্যালু হিসেবে পাঠানো (Value Types)
Primitive Types:

String: উদাহরণ: "hello"
Number: উদাহরণ: 42
Boolean: উদাহরণ: true বা false
Undefined: যখন একটি ভেরিয়েবল ঘোষণা করা হয় কিন্তু এতে কোনো মান নেই।
Null: একটি উদ্দেশ্যবিহীন মান।
Symbol: এক ধরনের অদ্বিতীয় মান।
BigInt: বড় সংখ্যার জন্য ব্যবহৃত।
এগুলোকে ফাংশনে পাঠানোর সময় ভ্যালু হিসেবে পাঠানো হয়, অর্থাৎ ফাংশনের মধ্যে এই ভেরিয়েবলগুলোর পরিবর্তন মূল ভেরিয়েবলকে প্রভাবিত করে না। উদাহরণ:

২. রেফারেন্স হিসেবে পাঠানো (Reference Types)
Complex Types:

Object: উদাহরণ: { name: "Rahat" }
Array: উদাহরণ: [1, 2, 3]
Function: ফাংশনও একটি অবজেক্ট, তাই এটিও রেফারেন্স হিসেবে পাঠানো হয়।
এই ভেরিয়েবলগুলোকে ফাংশনে পাঠানোর সময় রেফারেন্স হিসেবে পাঠানো হয়, অর্থাৎ ফাংশনের মধ্যে এদের পরিবর্তন মূল ভেরিয়েবলকে প্রভাবিত করে। উদাহরণ:

উপসংহার
সুতরাং, প্রাইমিটিভ টাইপের ভেরিয়েবলগুলো ফাংশনে ভ্যালু হিসেবে পাঠানো হয়, আর অবজেক্ট এবং অন্যান্য কমপ্লেক্স টাইপের ভেরিয়েবলগুলো রেফারেন্স হিসেবে পাঠানো হয়।
 * 
 * 
 * 
 * 
 * 
 * 
 */